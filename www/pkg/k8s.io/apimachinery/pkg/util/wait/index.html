<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="theme-color" content="#375EAB">

  <title>wait - Go Documentation Server</title>

<link type="text/css" rel="stylesheet" href="../../../../../../lib/godoc/style.css">

<script>window.initFuncs = [];</script>
<script src="../../../../../../lib/godoc/jquery.js" defer></script>



<script>var goVersion = "go1.15.6";</script>
<script src="../../../../../../lib/godoc/godocs.js" defer></script>
</head>
<body>

<div id='lowframe' style="position: fixed; bottom: 0; left: 0; height: 0; width: 100%; border-top: thin solid grey; background-color: white; overflow: auto;">
...
</div><!-- #lowframe -->

<div id="topbar" class="wide"><div class="container">
<div class="top-heading" id="heading-wide"><a href="http://localhost:6060/pkg/">Go Documentation Server</a></div>
<div class="top-heading" id="heading-narrow"><a href="http://localhost:6060/pkg/">GoDoc</a></div>
<a href="index.html#" id="menu-button"><span id="menu-button-arrow">&#9661;</span></a>
<form method="GET" action="http://localhost:6060/search">
<div id="menu">

<span class="search-box"><input type="search" id="search" name="q" placeholder="Search" aria-label="Search" required><button type="submit"><span><!-- magnifying glass: --><svg width="24" height="24" viewBox="0 0 24 24"><title>submit search</title><path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/><path d="M0 0h24v24H0z" fill="none"/></svg></span></button></span>
</div>
</form>

</div></div>



<div id="page" class="wide">
<div class="container">


  <h1>
    Package wait
    <span class="text-muted"></span>
  </h1>







<div id="nav"></div>


<!--
	Copyright 2009 The Go Authors. All rights reserved.
	Use of this source code is governed by a BSD-style
	license that can be found in the LICENSE file.
-->
<!--
	Note: Static (i.e., not template-generated) href and id
	attributes start with "pkg-" to make it impossible for
	them to conflict with generated attributes (some of which
	correspond to Go identifiers).
-->

	<script>
	document.ANALYSIS_DATA = null;
	document.CALLGRAPH = null;
	</script>

	
		
		<div id="short-nav">
			<dl>
			<dd><code>import "k8s.io/apimachinery/pkg/util/wait"</code></dd>
			</dl>
			<dl>
			<dd><a href="index.html#pkg-overview" class="overviewLink">Overview</a></dd>
			<dd><a href="index.html#pkg-index" class="indexLink">Index</a></dd>
			
			
			</dl>
		</div>
		<!-- The package's Name is printed as title by the top-level template -->
		<div id="pkg-overview" class="toggleVisible">
			<div class="collapsed">
				<h2 class="toggleButton" title="Click to show Overview section">Overview ▹</h2>
			</div>
			<div class="expanded">
				<h2 class="toggleButton" title="Click to hide Overview section">Overview ▾</h2>
				<p>
Package wait provides tools for polling or listening for changes
to a condition.
</p>

				
			</div>
		</div>

		<div id="pkg-index" class="toggleVisible">
		<div class="collapsed">
			<h2 class="toggleButton" title="Click to show Index section">Index ▹</h2>
		</div>
		<div class="expanded">
			<h2 class="toggleButton" title="Click to hide Index section">Index ▾</h2>

		<!-- Table of contents for API; must be named manual-nav to turn off auto nav. -->
			<div id="manual-nav">
			<dl>
			
			
				<dd><a href="index.html#pkg-variables">Variables</a></dd>
			
			
				
				<dd><a href="index.html#BackoffUntil">func BackoffUntil(f func(), backoff BackoffManager, sliding bool, stopCh &lt;-chan struct{})</a></dd>
			
				
				<dd><a href="index.html#ExponentialBackoff">func ExponentialBackoff(backoff Backoff, condition ConditionFunc) error</a></dd>
			
				
				<dd><a href="index.html#ExponentialBackoffWithContext">func ExponentialBackoffWithContext(ctx context.Context, backoff Backoff, condition ConditionFunc) error</a></dd>
			
				
				<dd><a href="index.html#Forever">func Forever(f func(), period time.Duration)</a></dd>
			
				
				<dd><a href="index.html#Jitter">func Jitter(duration time.Duration, maxFactor float64) time.Duration</a></dd>
			
				
				<dd><a href="index.html#JitterUntil">func JitterUntil(f func(), period time.Duration, jitterFactor float64, sliding bool, stopCh &lt;-chan struct{})</a></dd>
			
				
				<dd><a href="index.html#JitterUntilWithContext">func JitterUntilWithContext(ctx context.Context, f func(context.Context), period time.Duration, jitterFactor float64, sliding bool)</a></dd>
			
				
				<dd><a href="index.html#NonSlidingUntil">func NonSlidingUntil(f func(), period time.Duration, stopCh &lt;-chan struct{})</a></dd>
			
				
				<dd><a href="index.html#NonSlidingUntilWithContext">func NonSlidingUntilWithContext(ctx context.Context, f func(context.Context), period time.Duration)</a></dd>
			
				
				<dd><a href="index.html#Poll">func Poll(interval, timeout time.Duration, condition ConditionFunc) error</a></dd>
			
				
				<dd><a href="index.html#PollImmediate">func PollImmediate(interval, timeout time.Duration, condition ConditionFunc) error</a></dd>
			
				
				<dd><a href="index.html#PollImmediateInfinite">func PollImmediateInfinite(interval time.Duration, condition ConditionFunc) error</a></dd>
			
				
				<dd><a href="index.html#PollImmediateUntil">func PollImmediateUntil(interval time.Duration, condition ConditionFunc, stopCh &lt;-chan struct{}) error</a></dd>
			
				
				<dd><a href="index.html#PollInfinite">func PollInfinite(interval time.Duration, condition ConditionFunc) error</a></dd>
			
				
				<dd><a href="index.html#PollUntil">func PollUntil(interval time.Duration, condition ConditionFunc, stopCh &lt;-chan struct{}) error</a></dd>
			
				
				<dd><a href="index.html#Until">func Until(f func(), period time.Duration, stopCh &lt;-chan struct{})</a></dd>
			
				
				<dd><a href="index.html#UntilWithContext">func UntilWithContext(ctx context.Context, f func(context.Context), period time.Duration)</a></dd>
			
				
				<dd><a href="index.html#WaitFor">func WaitFor(wait WaitFunc, fn ConditionFunc, done &lt;-chan struct{}) error</a></dd>
			
			
				
				<dd><a href="index.html#Backoff">type Backoff</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Backoff.Step">func (b *Backoff) Step() time.Duration</a></dd>
				
			
				
				<dd><a href="index.html#BackoffManager">type BackoffManager</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#NewExponentialBackoffManager">func NewExponentialBackoffManager(initBackoff, maxBackoff, resetDuration time.Duration, backoffFactor, jitter float64, c clock.Clock) BackoffManager</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#NewJitteredBackoffManager">func NewJitteredBackoffManager(duration time.Duration, jitter float64, c clock.Clock) BackoffManager</a></dd>
				
				
			
				
				<dd><a href="index.html#ConditionFunc">type ConditionFunc</a></dd>
				
				
			
				
				<dd><a href="index.html#Group">type Group</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Group.Start">func (g *Group) Start(f func())</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Group.StartWithChannel">func (g *Group) StartWithChannel(stopCh &lt;-chan struct{}, f func(stopCh &lt;-chan struct{}))</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Group.StartWithContext">func (g *Group) StartWithContext(ctx context.Context, f func(context.Context))</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Group.Wait">func (g *Group) Wait()</a></dd>
				
			
				
				<dd><a href="index.html#WaitFunc">type WaitFunc</a></dd>
				
				
			
			
			</dl>
			</div><!-- #manual-nav -->

		

		
			<h3>Package files</h3>
			<p>
			<span style="font-size:90%">
			
				<a href="http://localhost:6060/src/k8s.io/apimachinery/pkg/util/wait/doc.go">doc.go</a>
			
				<a href="http://localhost:6060/src/k8s.io/apimachinery/pkg/util/wait/wait.go">wait.go</a>
			
			</span>
			</p>
		
		</div><!-- .expanded -->
		</div><!-- #pkg-index -->

		

		
		
			<h2 id="pkg-variables">Variables</h2>
			
				<p>
ErrWaitTimeout is returned when the condition exited without success.
</p>

				<pre>var <span id="ErrWaitTimeout">ErrWaitTimeout</span> = <a href="http://localhost:6060/pkg/errors/">errors</a>.<a href="http://localhost:6060/pkg/errors/#New">New</a>(&#34;timed out waiting for the condition&#34;)</pre>
			
				<p>
For any test of the style:
</p>
<pre>...
&lt;- time.After(timeout):
   t.Errorf(&#34;Timed out&#34;)
</pre>
<p>
The value for timeout should effectively be &#34;forever.&#34; Obviously we don&#39;t want our tests to truly lock up forever, but 30s
is long enough that it is effectively forever for the things that can slow down a run on a heavily contended machine
(GC, seeks, etc), but not so long as to make a developer ctrl-c a test run if they do happen to break that test.
</p>

				<pre>var <span id="ForeverTestTimeout">ForeverTestTimeout</span> = <a href="http://localhost:6060/pkg/time/">time</a>.<a href="http://localhost:6060/pkg/time/#Second">Second</a> * 30</pre>
			
				<p>
NeverStop may be passed to Until to make it never stop.
</p>

				<pre>var <span id="NeverStop">NeverStop</span> &lt;-chan struct{} = <a href="http://localhost:6060/pkg/builtin/#make">make</a>(chan struct{})</pre>
			
		
		
			
			
			<h2 id="BackoffUntil">func <a href="http://localhost:6060/src/k8s.io/apimachinery/pkg/util/wait/wait.go?s=4909:4998#L130">BackoffUntil</a>
				<a class="permalink" href="index.html#BackoffUntil">&#xb6;</a>
				
				
			</h2>
			<pre>func BackoffUntil(f func(), backoff <a href="index.html#BackoffManager">BackoffManager</a>, sliding <a href="http://localhost:6060/pkg/builtin/#bool">bool</a>, stopCh &lt;-chan struct{})</pre>
			<p>
BackoffUntil loops until stop channel is closed, run f every duration given by BackoffManager.
</p>
<p>
If sliding is true, the period is computed after f runs. If it is false then
period includes the runtime for f.
</p>

			
			

		
			
			
			<h2 id="ExponentialBackoff">func <a href="http://localhost:6060/src/k8s.io/apimachinery/pkg/util/wait/wait.go?s=13727:13798#L387">ExponentialBackoff</a>
				<a class="permalink" href="index.html#ExponentialBackoff">&#xb6;</a>
				
				
			</h2>
			<pre>func ExponentialBackoff(backoff <a href="index.html#Backoff">Backoff</a>, condition <a href="index.html#ConditionFunc">ConditionFunc</a>) <a href="http://localhost:6060/pkg/builtin/#error">error</a></pre>
			<p>
ExponentialBackoff repeats a condition check with exponential backoff.
</p>
<p>
It repeatedly checks the condition and then sleeps, using `backoff.Step()`
to determine the length of the sleep and adjust Duration and Steps.
Stops and returns as soon as:
1. the condition check returns true or an error,
2. `backoff.Steps` checks of the condition have been done, or
3. a sleep truncated by the cap on duration has been completed.
In case (1) the returned error is what the condition function returned.
In all other cases, ErrWaitTimeout is returned.
</p>

			
			

		
			
			
			<h2 id="ExponentialBackoffWithContext">func <a href="http://localhost:6060/src/k8s.io/apimachinery/pkg/util/wait/wait.go?s=20268:20371#L600">ExponentialBackoffWithContext</a>
				<a class="permalink" href="index.html#ExponentialBackoffWithContext">&#xb6;</a>
				
				
			</h2>
			<pre>func ExponentialBackoffWithContext(ctx <a href="http://localhost:6060/pkg/context/">context</a>.<a href="http://localhost:6060/pkg/context/#Context">Context</a>, backoff <a href="index.html#Backoff">Backoff</a>, condition <a href="index.html#ConditionFunc">ConditionFunc</a>) <a href="http://localhost:6060/pkg/builtin/#error">error</a></pre>
			<p>
ExponentialBackoffWithContext works with a request context and a Backoff. It ensures that the retry wait never
exceeds the deadline specified by the request context.
</p>

			
			

		
			
			
			<h2 id="Forever">func <a href="http://localhost:6060/src/k8s.io/apimachinery/pkg/util/wait/wait.go?s=2277:2321#L70">Forever</a>
				<a class="permalink" href="index.html#Forever">&#xb6;</a>
				
				
			</h2>
			<pre>func Forever(f func(), period <a href="http://localhost:6060/pkg/time/">time</a>.<a href="http://localhost:6060/pkg/time/#Duration">Duration</a>)</pre>
			<p>
Forever calls f every period for ever.
</p>
<p>
Forever is syntactic sugar on top of Until.
</p>

			
			

		
			
			
			<h2 id="Jitter">func <a href="http://localhost:6060/src/k8s.io/apimachinery/pkg/util/wait/wait.go?s=6457:6525#L183">Jitter</a>
				<a class="permalink" href="index.html#Jitter">&#xb6;</a>
				
				
			</h2>
			<pre>func Jitter(duration <a href="http://localhost:6060/pkg/time/">time</a>.<a href="http://localhost:6060/pkg/time/#Duration">Duration</a>, maxFactor <a href="http://localhost:6060/pkg/builtin/#float64">float64</a>) <a href="http://localhost:6060/pkg/time/">time</a>.<a href="http://localhost:6060/pkg/time/#Duration">Duration</a></pre>
			<p>
Jitter returns a time.Duration between duration and duration + maxFactor *
duration.
</p>
<p>
This allows clients to avoid converging on periodic behavior. If maxFactor
is 0.0, a suggested default value will be chosen.
</p>

			
			

		
			
			
			<h2 id="JitterUntil">func <a href="http://localhost:6060/src/k8s.io/apimachinery/pkg/util/wait/wait.go?s=4473:4581#L122">JitterUntil</a>
				<a class="permalink" href="index.html#JitterUntil">&#xb6;</a>
				
				
			</h2>
			<pre>func JitterUntil(f func(), period <a href="http://localhost:6060/pkg/time/">time</a>.<a href="http://localhost:6060/pkg/time/#Duration">Duration</a>, jitterFactor <a href="http://localhost:6060/pkg/builtin/#float64">float64</a>, sliding <a href="http://localhost:6060/pkg/builtin/#bool">bool</a>, stopCh &lt;-chan struct{})</pre>
			<p>
JitterUntil loops until stop channel is closed, running f every period.
</p>
<p>
If jitterFactor is positive, the period is jittered before every run of f.
If jitterFactor is not positive, the period is unchanged and not jittered.
</p>
<p>
If sliding is true, the period is computed after f runs. If it is false then
period includes the runtime for f.
</p>
<p>
Close stopCh to stop. f may not be invoked if stop channel is already
closed. Pass NeverStop to if you don&#39;t want it stop.
</p>

			
			

		
			
			
			<h2 id="JitterUntilWithContext">func <a href="http://localhost:6060/src/k8s.io/apimachinery/pkg/util/wait/wait.go?s=6020:6151#L174">JitterUntilWithContext</a>
				<a class="permalink" href="index.html#JitterUntilWithContext">&#xb6;</a>
				
				
			</h2>
			<pre>func JitterUntilWithContext(ctx <a href="http://localhost:6060/pkg/context/">context</a>.<a href="http://localhost:6060/pkg/context/#Context">Context</a>, f func(<a href="http://localhost:6060/pkg/context/">context</a>.<a href="http://localhost:6060/pkg/context/#Context">Context</a>), period <a href="http://localhost:6060/pkg/time/">time</a>.<a href="http://localhost:6060/pkg/time/#Duration">Duration</a>, jitterFactor <a href="http://localhost:6060/pkg/builtin/#float64">float64</a>, sliding <a href="http://localhost:6060/pkg/builtin/#bool">bool</a>)</pre>
			<p>
JitterUntilWithContext loops until context is done, running f every period.
</p>
<p>
If jitterFactor is positive, the period is jittered before every run of f.
If jitterFactor is not positive, the period is unchanged and not jittered.
</p>
<p>
If sliding is true, the period is computed after f runs. If it is false then
period includes the runtime for f.
</p>
<p>
Cancel context to stop. f may not be invoked if context is already expired.
</p>

			
			

		
			
			
			<h2 id="NonSlidingUntil">func <a href="http://localhost:6060/src/k8s.io/apimachinery/pkg/util/wait/wait.go?s=3401:3477#L98">NonSlidingUntil</a>
				<a class="permalink" href="index.html#NonSlidingUntil">&#xb6;</a>
				
				
			</h2>
			<pre>func NonSlidingUntil(f func(), period <a href="http://localhost:6060/pkg/time/">time</a>.<a href="http://localhost:6060/pkg/time/#Duration">Duration</a>, stopCh &lt;-chan struct{})</pre>
			<p>
NonSlidingUntil loops until stop channel is closed, running f every
period.
</p>
<p>
NonSlidingUntil is syntactic sugar on top of JitterUntil with zero jitter
factor, with sliding = false (meaning the timer for period starts at the same
time as the function starts).
</p>

			
			

		
			
			
			<h2 id="NonSlidingUntilWithContext">func <a href="http://localhost:6060/src/k8s.io/apimachinery/pkg/util/wait/wait.go?s=3829:3928#L108">NonSlidingUntilWithContext</a>
				<a class="permalink" href="index.html#NonSlidingUntilWithContext">&#xb6;</a>
				
				
			</h2>
			<pre>func NonSlidingUntilWithContext(ctx <a href="http://localhost:6060/pkg/context/">context</a>.<a href="http://localhost:6060/pkg/context/#Context">Context</a>, f func(<a href="http://localhost:6060/pkg/context/">context</a>.<a href="http://localhost:6060/pkg/context/#Context">Context</a>), period <a href="http://localhost:6060/pkg/time/">time</a>.<a href="http://localhost:6060/pkg/time/#Duration">Duration</a>)</pre>
			<p>
NonSlidingUntilWithContext loops until context is done, running f every
period.
</p>
<p>
NonSlidingUntilWithContext is syntactic sugar on top of JitterUntilWithContext
with zero jitter factor, with sliding = false (meaning the timer for period
starts at the same time as the function starts).
</p>

			
			

		
			
			
			<h2 id="Poll">func <a href="http://localhost:6060/src/k8s.io/apimachinery/pkg/util/wait/wait.go?s=14401:14474#L410">Poll</a>
				<a class="permalink" href="index.html#Poll">&#xb6;</a>
				
				
			</h2>
			<pre>func Poll(interval, timeout <a href="http://localhost:6060/pkg/time/">time</a>.<a href="http://localhost:6060/pkg/time/#Duration">Duration</a>, condition <a href="index.html#ConditionFunc">ConditionFunc</a>) <a href="http://localhost:6060/pkg/builtin/#error">error</a></pre>
			<p>
Poll tries a condition func until it returns true, an error, or the timeout
is reached.
</p>
<p>
Poll always waits the interval before the run of &#39;condition&#39;.
&#39;condition&#39; will always be invoked at least once.
</p>
<p>
Some intervals may be missed if the condition takes too long or the time
window is too short.
</p>
<p>
If you want to Poll something forever, see PollInfinite.
</p>

			
			

		
			
			
			<h2 id="PollImmediate">func <a href="http://localhost:6060/src/k8s.io/apimachinery/pkg/util/wait/wait.go?s=15117:15199#L430">PollImmediate</a>
				<a class="permalink" href="index.html#PollImmediate">&#xb6;</a>
				
				
			</h2>
			<pre>func PollImmediate(interval, timeout <a href="http://localhost:6060/pkg/time/">time</a>.<a href="http://localhost:6060/pkg/time/#Duration">Duration</a>, condition <a href="index.html#ConditionFunc">ConditionFunc</a>) <a href="http://localhost:6060/pkg/builtin/#error">error</a></pre>
			<p>
PollImmediate tries a condition func until it returns true, an error, or the timeout
is reached.
</p>
<p>
PollImmediate always checks &#39;condition&#39; before waiting for the interval. &#39;condition&#39;
will always be invoked at least once.
</p>
<p>
Some intervals may be missed if the condition takes too long or the time
window is too short.
</p>
<p>
If you want to immediately Poll something forever, see PollImmediateInfinite.
</p>

			
			

		
			
			
			<h2 id="PollImmediateInfinite">func <a href="http://localhost:6060/src/k8s.io/apimachinery/pkg/util/wait/wait.go?s=16196:16277#L463">PollImmediateInfinite</a>
				<a class="permalink" href="index.html#PollImmediateInfinite">&#xb6;</a>
				
				
			</h2>
			<pre>func PollImmediateInfinite(interval <a href="http://localhost:6060/pkg/time/">time</a>.<a href="http://localhost:6060/pkg/time/#Duration">Duration</a>, condition <a href="index.html#ConditionFunc">ConditionFunc</a>) <a href="http://localhost:6060/pkg/builtin/#error">error</a></pre>
			<p>
PollImmediateInfinite tries a condition func until it returns true or an error
</p>
<p>
PollImmediateInfinite runs the &#39;condition&#39; before waiting for the interval.
</p>
<p>
Some intervals may be missed if the condition takes too long or the time
window is too short.
</p>

			
			

		
			
			
			<h2 id="PollImmediateUntil">func <a href="http://localhost:6060/src/k8s.io/apimachinery/pkg/util/wait/wait.go?s=17109:17211#L489">PollImmediateUntil</a>
				<a class="permalink" href="index.html#PollImmediateUntil">&#xb6;</a>
				
				
			</h2>
			<pre>func PollImmediateUntil(interval <a href="http://localhost:6060/pkg/time/">time</a>.<a href="http://localhost:6060/pkg/time/#Duration">Duration</a>, condition <a href="index.html#ConditionFunc">ConditionFunc</a>, stopCh &lt;-chan struct{}) <a href="http://localhost:6060/pkg/builtin/#error">error</a></pre>
			<p>
PollImmediateUntil tries a condition func until it returns true, an error or stopCh is closed.
</p>
<p>
PollImmediateUntil runs the &#39;condition&#39; before waiting for the interval.
&#39;condition&#39; will always be invoked at least once.
</p>

			
			

		
			
			
			<h2 id="PollInfinite">func <a href="http://localhost:6060/src/k8s.io/apimachinery/pkg/util/wait/wait.go?s=15758:15830#L451">PollInfinite</a>
				<a class="permalink" href="index.html#PollInfinite">&#xb6;</a>
				
				
			</h2>
			<pre>func PollInfinite(interval <a href="http://localhost:6060/pkg/time/">time</a>.<a href="http://localhost:6060/pkg/time/#Duration">Duration</a>, condition <a href="index.html#ConditionFunc">ConditionFunc</a>) <a href="http://localhost:6060/pkg/builtin/#error">error</a></pre>
			<p>
PollInfinite tries a condition func until it returns true or an error
</p>
<p>
PollInfinite always waits the interval before the run of &#39;condition&#39;.
</p>
<p>
Some intervals may be missed if the condition takes too long or the time
window is too short.
</p>

			
			

		
			
			
			<h2 id="PollUntil">func <a href="http://localhost:6060/src/k8s.io/apimachinery/pkg/util/wait/wait.go?s=16662:16755#L479">PollUntil</a>
				<a class="permalink" href="index.html#PollUntil">&#xb6;</a>
				
				
			</h2>
			<pre>func PollUntil(interval <a href="http://localhost:6060/pkg/time/">time</a>.<a href="http://localhost:6060/pkg/time/#Duration">Duration</a>, condition <a href="index.html#ConditionFunc">ConditionFunc</a>, stopCh &lt;-chan struct{}) <a href="http://localhost:6060/pkg/builtin/#error">error</a></pre>
			<p>
PollUntil tries a condition func until it returns true, an error or stopCh is
closed.
</p>
<p>
PollUntil always waits interval before the first run of &#39;condition&#39;.
&#39;condition&#39; will always be invoked at least once.
</p>

			
			

		
			
			
			<h2 id="Until">func <a href="http://localhost:6060/src/k8s.io/apimachinery/pkg/util/wait/wait.go?s=2597:2663#L79">Until</a>
				<a class="permalink" href="index.html#Until">&#xb6;</a>
				
				
			</h2>
			<pre>func Until(f func(), period <a href="http://localhost:6060/pkg/time/">time</a>.<a href="http://localhost:6060/pkg/time/#Duration">Duration</a>, stopCh &lt;-chan struct{})</pre>
			<p>
Until loops until stop channel is closed, running f every period.
</p>
<p>
Until is syntactic sugar on top of JitterUntil with zero jitter factor and
with sliding = true (which means the timer for period starts after the f
completes).
</p>

			
			

		
			
			
			<h2 id="UntilWithContext">func <a href="http://localhost:6060/src/k8s.io/apimachinery/pkg/util/wait/wait.go?s=2979:3068#L88">UntilWithContext</a>
				<a class="permalink" href="index.html#UntilWithContext">&#xb6;</a>
				
				
			</h2>
			<pre>func UntilWithContext(ctx <a href="http://localhost:6060/pkg/context/">context</a>.<a href="http://localhost:6060/pkg/context/#Context">Context</a>, f func(<a href="http://localhost:6060/pkg/context/">context</a>.<a href="http://localhost:6060/pkg/context/#Context">Context</a>), period <a href="http://localhost:6060/pkg/time/">time</a>.<a href="http://localhost:6060/pkg/time/#Duration">Duration</a>)</pre>
			<p>
UntilWithContext loops until context is done, running f every period.
</p>
<p>
UntilWithContext is syntactic sugar on top of JitterUntilWithContext
with zero jitter factor and with sliding = true (which means the timer
for period starts after the f completes).
</p>

			
			

		
			
			
			<h2 id="WaitFor">func <a href="http://localhost:6060/src/k8s.io/apimachinery/pkg/util/wait/wait.go?s=18361:18434#L524">WaitFor</a>
				<a class="permalink" href="index.html#WaitFor">&#xb6;</a>
				
				
			</h2>
			<pre>func WaitFor(wait <a href="index.html#WaitFunc">WaitFunc</a>, fn <a href="index.html#ConditionFunc">ConditionFunc</a>, done &lt;-chan struct{}) <a href="http://localhost:6060/pkg/builtin/#error">error</a></pre>
			<p>
WaitFor continually checks &#39;fn&#39; as driven by &#39;wait&#39;.
</p>
<p>
WaitFor gets a channel from &#39;wait()&rdquo;, and then invokes &#39;fn&#39; once for every value
placed on the channel and once more when the channel is closed. If the channel is closed
and &#39;fn&#39; returns false without error, WaitFor returns ErrWaitTimeout.
</p>
<p>
If &#39;fn&#39; returns an error the loop ends and that error is returned. If
&#39;fn&#39; returns true the loop ends and nil is returned.
</p>
<p>
ErrWaitTimeout will be returned if the &#39;done&#39; channel is closed without fn ever
returning true.
</p>
<p>
When the done channel is closed, because the golang `select` statement is
&#34;uniform pseudo-random&#34;, the `fn` might still run one or multiple time,
though eventually `WaitFor` will return.
</p>

			
			

		
		
			
			
			<h2 id="Backoff">type <a href="http://localhost:6060/src/k8s.io/apimachinery/pkg/util/wait/wait.go?s=7235:8275#L205">Backoff</a>
				<a class="permalink" href="index.html#Backoff">&#xb6;</a>
				
				
			</h2>
			<p>
Backoff holds parameters applied to a Backoff function.
</p>

			<pre>type Backoff struct {
    <span class="comment">// The initial duration.</span>
<span id="Backoff.Duration"></span>    Duration <a href="http://localhost:6060/pkg/time/">time</a>.<a href="http://localhost:6060/pkg/time/#Duration">Duration</a>
    <span class="comment">// Duration is multiplied by factor each iteration, if factor is not zero</span>
    <span class="comment">// and the limits imposed by Steps and Cap have not been reached.</span>
    <span class="comment">// Should not be negative.</span>
    <span class="comment">// The jitter does not contribute to the updates to the duration parameter.</span>
<span id="Backoff.Factor"></span>    Factor <a href="http://localhost:6060/pkg/builtin/#float64">float64</a>
    <span class="comment">// The sleep at each iteration is the duration plus an additional</span>
    <span class="comment">// amount chosen uniformly at random from the interval between</span>
    <span class="comment">// zero and `jitter*duration`.</span>
<span id="Backoff.Jitter"></span>    Jitter <a href="http://localhost:6060/pkg/builtin/#float64">float64</a>
    <span class="comment">// The remaining number of iterations in which the duration</span>
    <span class="comment">// parameter may change (but progress can be stopped earlier by</span>
    <span class="comment">// hitting the cap). If not positive, the duration is not</span>
    <span class="comment">// changed. Used for exponential backoff in combination with</span>
    <span class="comment">// Factor and Cap.</span>
<span id="Backoff.Steps"></span>    Steps <a href="http://localhost:6060/pkg/builtin/#int">int</a>
    <span class="comment">// A limit on revised values of the duration parameter. If a</span>
    <span class="comment">// multiplication by the factor parameter would make the duration</span>
    <span class="comment">// exceed the cap then the duration is set to the cap and the</span>
    <span class="comment">// steps parameter is set to zero.</span>
<span id="Backoff.Cap"></span>    Cap <a href="http://localhost:6060/pkg/time/">time</a>.<a href="http://localhost:6060/pkg/time/#Duration">Duration</a>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="Backoff.Step">func (*Backoff) <a href="http://localhost:6060/src/k8s.io/apimachinery/pkg/util/wait/wait.go?s=8448:8486#L233">Step</a>
					<a class="permalink" href="index.html#Backoff.Step">&#xb6;</a>
					
					
				</h3>
				<pre>func (b *<a href="index.html#Backoff">Backoff</a>) Step() <a href="http://localhost:6060/pkg/time/">time</a>.<a href="http://localhost:6060/pkg/time/#Duration">Duration</a></pre>
				<p>
Step (1) returns an amount of time to sleep determined by the
original Duration and Jitter and (2) mutates the provided Backoff
to update its Steps and Duration.
</p>

				
				
				
			
		
			
			
			<h2 id="BackoffManager">type <a href="http://localhost:6060/src/k8s.io/apimachinery/pkg/util/wait/wait.go?s=9939:9995#L283">BackoffManager</a>
				<a class="permalink" href="index.html#BackoffManager">&#xb6;</a>
				
				
			</h2>
			<p>
BackoffManager manages backoff with a particular scheme based on its underlying implementation. It provides
an interface to return a timer for backoff, and caller shall backoff until Timer.C() drains. If the second Backoff()
is called before the timer from the first Backoff() call finishes, the first timer will NOT be drained and result in
undetermined behavior.
The BackoffManager is supposed to be called in a single-threaded environment.
</p>

			<pre>type BackoffManager interface {
    Backoff() <a href="../clock/index.html">clock</a>.<a href="../clock/index.html#Timer">Timer</a>
}</pre>

			

			

			
			
			

			
				
				<h3 id="NewExponentialBackoffManager">func <a href="http://localhost:6060/src/k8s.io/apimachinery/pkg/util/wait/wait.go?s=10553:10701#L299">NewExponentialBackoffManager</a>
					<a class="permalink" href="index.html#NewExponentialBackoffManager">&#xb6;</a>
					
					
				</h3>
				<pre>func NewExponentialBackoffManager(initBackoff, maxBackoff, resetDuration <a href="http://localhost:6060/pkg/time/">time</a>.<a href="http://localhost:6060/pkg/time/#Duration">Duration</a>, backoffFactor, jitter <a href="http://localhost:6060/pkg/builtin/#float64">float64</a>, c <a href="../clock/index.html">clock</a>.<a href="../clock/index.html#Clock">Clock</a>) <a href="index.html#BackoffManager">BackoffManager</a></pre>
				<p>
NewExponentialBackoffManager returns a manager for managing exponential backoff. Each backoff is jittered and
backoff will not exceed the given max. If the backoff is not called within resetDuration, the backoff is reset.
This backoff manager is used to reduce load during upstream unhealthiness.
</p>

				
				
			
				
				<h3 id="NewJitteredBackoffManager">func <a href="http://localhost:6060/src/k8s.io/apimachinery/pkg/util/wait/wait.go?s=12289:12389#L348">NewJitteredBackoffManager</a>
					<a class="permalink" href="index.html#NewJitteredBackoffManager">&#xb6;</a>
					
					
				</h3>
				<pre>func NewJitteredBackoffManager(duration <a href="http://localhost:6060/pkg/time/">time</a>.<a href="http://localhost:6060/pkg/time/#Duration">Duration</a>, jitter <a href="http://localhost:6060/pkg/builtin/#float64">float64</a>, c <a href="../clock/index.html">clock</a>.<a href="../clock/index.html#Clock">Clock</a>) <a href="index.html#BackoffManager">BackoffManager</a></pre>
				<p>
NewJitteredBackoffManager returns a BackoffManager that backoffs with given duration plus given jitter. If the jitter
is negative, backoff will not be jittered.
</p>

				
				
			

			
		
			
			
			<h2 id="ConditionFunc">type <a href="http://localhost:6060/src/k8s.io/apimachinery/pkg/util/wait/wait.go?s=6918:6966#L196">ConditionFunc</a>
				<a class="permalink" href="index.html#ConditionFunc">&#xb6;</a>
				
				
			</h2>
			<p>
ConditionFunc returns true if the condition is satisfied, or an error
if the loop should be aborted.
</p>

			<pre>type ConditionFunc func() (done <a href="http://localhost:6060/pkg/builtin/#bool">bool</a>, err <a href="http://localhost:6060/pkg/builtin/#error">error</a>)</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="Group">type <a href="http://localhost:6060/src/k8s.io/apimachinery/pkg/util/wait/wait.go?s=1427:1467#L34">Group</a>
				<a class="permalink" href="index.html#Group">&#xb6;</a>
				
				
			</h2>
			<p>
Group allows to start a group of goroutines and wait for their completion.
</p>

			<pre>type Group struct {
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="Group.Start">func (*Group) <a href="http://localhost:6060/src/k8s.io/apimachinery/pkg/util/wait/wait.go?s=2091:2122#L59">Start</a>
					<a class="permalink" href="index.html#Group.Start">&#xb6;</a>
					
					
				</h3>
				<pre>func (g *<a href="index.html#Group">Group</a>) Start(f func())</pre>
				<p>
Start starts f in a new goroutine in the group.
</p>

				
				
				
			
				
				<h3 id="Group.StartWithChannel">func (*Group) <a href="http://localhost:6060/src/k8s.io/apimachinery/pkg/util/wait/wait.go?s=1653:1741#L44">StartWithChannel</a>
					<a class="permalink" href="index.html#Group.StartWithChannel">&#xb6;</a>
					
					
				</h3>
				<pre>func (g *<a href="index.html#Group">Group</a>) StartWithChannel(stopCh &lt;-chan struct{}, f func(stopCh &lt;-chan struct{}))</pre>
				<p>
StartWithChannel starts f in a new goroutine in the group.
stopCh is passed to f as an argument. f should stop when stopCh is available.
</p>

				
				
				
			
				
				<h3 id="Group.StartWithContext">func (*Group) <a href="http://localhost:6060/src/k8s.io/apimachinery/pkg/util/wait/wait.go?s=1925:2003#L52">StartWithContext</a>
					<a class="permalink" href="index.html#Group.StartWithContext">&#xb6;</a>
					
					
				</h3>
				<pre>func (g *<a href="index.html#Group">Group</a>) StartWithContext(ctx <a href="http://localhost:6060/pkg/context/">context</a>.<a href="http://localhost:6060/pkg/context/#Context">Context</a>, f func(<a href="http://localhost:6060/pkg/context/">context</a>.<a href="http://localhost:6060/pkg/context/#Context">Context</a>))</pre>
				<p>
StartWithContext starts f in a new goroutine in the group.
ctx is passed to f as an argument. f should stop when ctx.Done() is available.
</p>

				
				
				
			
				
				<h3 id="Group.Wait">func (*Group) <a href="http://localhost:6060/src/k8s.io/apimachinery/pkg/util/wait/wait.go?s=1469:1491#L38">Wait</a>
					<a class="permalink" href="index.html#Group.Wait">&#xb6;</a>
					
					
				</h3>
				<pre>func (g *<a href="index.html#Group">Group</a>) Wait()</pre>
				
				
				
				
			
		
			
			
			<h2 id="WaitFunc">type <a href="http://localhost:6060/src/k8s.io/apimachinery/pkg/util/wait/wait.go?s=17558:17614#L507">WaitFunc</a>
				<a class="permalink" href="index.html#WaitFunc">&#xb6;</a>
				
				
			</h2>
			<p>
WaitFunc creates a channel that receives an item every time a test
should be executed and is closed when the last test should be invoked.
</p>

			<pre>type WaitFunc func(done &lt;-chan struct{}) &lt;-chan struct{}</pre>

			

			

			
			
			

			

			
		
	

	







<div id="footer">
Build version go1.15.6.<br>
Except as <a href="https://developers.google.com/site-policies#restrictions">noted</a>,
the content of this page is licensed under the
Creative Commons Attribution 3.0 License,
and code is licensed under a <a href="http://localhost:6060/LICENSE">BSD license</a>.<br>
<a href="http://localhost:6060/doc/tos.html">Terms of Service</a> |
<a href="http://www.google.com/intl/en/policies/privacy/">Privacy Policy</a>
</div>

</div><!-- .container -->
</div><!-- #page -->
</body>
</html>
